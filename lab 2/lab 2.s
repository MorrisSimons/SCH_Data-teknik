.equ CHAR_0, 0b00111111
.equ CHAR_1, 0b00000110
.equ CHAR_2, 0b01011011
.equ CHAR_3, 0b01001111
.equ CHAR_4, 0b01100110
.equ CHAR_5, 0b01101101
.equ CHAR_6, 0b01111101
.equ CHAR_7, 0b00000111
.equ CHAR_8, 0b01111111
.equ CHAR_9, 0b01101111
.equ CHAR_10, 0b01110111
.equ CHAR_11, 0b01111100
.equ CHAR_12, 0b00111001
.equ CHAR_13, 0b01011110
.equ CHAR_14, 0b01111001
.equ CHAR_15, 0b01110001
.equ INTERRUPT_VECTOR_BASE, 0x00000000
.equ SVC_MODE_STACK_BASE, 0x3FFFFFFF - 3 // set SVC stack to top of DDR3
memory
.equ IRQ_MODE_STACK_BASE, 0xFFFFFFFF - 3 // set IRQ stack to A9 onchip
memory
.equ GIC_CPU_INTERFACE_BASE, 0xFFFEC100
.equ GIC_DISTRIBUTOR_BASE, 0xFFFED000
.equ LED_BASE, 0xff200000
.equ SWITCHES_BASE, 0xff200040
.equ PUSH_BUTTONS_BASE, 0xff200050
.equ DISPLAYS_BASE, 0xff200020
.data
CHARS:
.word CHAR_0, CHAR_1, CHAR_2, CHAR_3, CHAR_4, CHAR_5, CHAR_6,
CHAR_7, CHAR_8, CHAR_9,CHAR_10,CHAR_11,CHAR_12,CHAR_13,CHAR_14,CHAR_15
COUNTER:
.word 0
.text
.org INTERRUPT_VECTOR_BASE
B RESET
B UNDEFINED
B SOFTWARE_INTERRUPT
B PREFETCH_ABORT
B DATA_ABORT
B UNKNOWN
B IRQ_INTERRUPT
B FIQ_INTERRUPT
RESET:
B _start
UNDEFINED:
B UNDEFINED
SOFTWARE_INTERRUPT:
B SOFTWARE_INTERRUPT
PREFETCH_ABORT:
B PREFETCH_ABORT
DATA_ABORT:
B DATA_ABORT
UNKNOWN:
B UNKNOWN
FIQ_INTERRUPT:
B FIQ_INTERRUPT
IRQ_INTERRUPT:
PUSH {R0-R8, LR}
LDR R4, =GIC_CPU_INTERFACE_BASE
LDR R5, [R4, #0x0C]
CMP R5, #73
BNE UNKNOWN
COUNTER_SWAPPER:
LDR r0, =COUNTER
LDR r1, [r0]
LDR r2, =PUSH_BUTTONS_BASE
LDR r3, [r2, #0xC]
CMP r3, #1
BEQ ADD_VALUE
CMP r3, #2
BEQ SUB_VALUE
ADD_VALUE:
ADD r1, #1
CMP r1, #16
BEQ SET_ZERO
B DISPLAY_VALUE
SUB_VALUE:
SUB r1, #1
CMP r1, #0
BLT SET_F
B DISPLAY_VALUE
SET_ZERO:
MOV r1, #0
B DISPLAY_VALUE
SET_F:
MOV r1, #15
B DISPLAY_VALUE
DISPLAY_VALUE:
LDR r4, =DISPLAYS_BASE
LDR r5, =CHARS
MOV r8, #4
MUL r8, r1
LDR r7, [r5, r8]
STR r7, [r4]
IRQ_INTERRUPT_END:
LDR R4, =GIC_CPU_INTERFACE_BASE
MOV R5, #73
STR R5, [R4, #0x10]
MOV r3, #0b1111
STR r3, [r2, #0xC]
STR r1, [r0]
POP {R0-R8, LR}
SUBS PC, LR, #4
.global _start
_start:
// Set IRQ mode
MOV R1, #0b11010010
MSR CPSR_c, R1
// Set SVC mode
LDR SP, =0xFFFFFFFF - 3
// Set the CPSR to enable IRQ mode
MOV R1, #0b11010011
MSR CPSR_c, R1
// Set the stack pointer for IRQ mode to A9 on-chip memory
LDR SP, =0x3FFFFFFF - 3
// Configure GIC
MOV r0, #73
BL CONFIG_GIC
// Configure push buttons
BL CONFIG_PUSH_BUTTONS
// Set the CPSR to enable user mode
MOV R1, #0b01010011
MSR CPSR_c, R1
MAIN:
B MAIN
CONFIG_PUSH_BUTTONS:
PUSH {lr}
ldr r0, =PUSH_BUTTONS_BASE
ldr r1, [r0, #8]
ORR r1, r1, #0x3
STR r1, [r0, #8]
POP {pc}
CONFIG_GIC:
PUSH {LR}
MOV R1, #1 // this field is a bit-mask
BL CONFIG_INTERRUPT
LDR R0, =GIC_CPU_INTERFACE_BASE // base address of CPU Interface,
0xFFFEC100
LDR R1, =0xFFFF // enable interrupts of all priorities levels
STR R1, [R0, #0x04]
MOV R1, #1
STR R1, [R0]
LDR R0, =GIC_DISTRIBUTOR_BASE // 0xFFFED000
STR R1, [R0]
POP {PC}
CONFIG_INTERRUPT:
PUSH {R4-R5, LR}
LSR R4, R0, #3 // calculate reg_offset
BIC R4, R4, #3 // R4 = reg_offset
LDR R2, =0xFFFED100 // Base address of ICDISERn
ADD R4, R2, R4 // R4 = address of ICDISER
AND R2, R0, #0x1F // N mod 32
MOV R5, #1 // enable
LSL R2, R5, R2 // R2 = value
LDR R3, [R4] // read current register value
ORR R3, R3, R2 // set the enable bit
STR R3, [R4] // store the new register value
BIC R4, R0, #3 // R4 = reg_offset
LDR R2, =0xFFFED800 // Base address of ICDIPTRn
ADD R4, R2, R4 // R4 = word address of ICDIPTR
AND R2, R0, #0x3 // N mod 4
ADD R4, R2, R4 // R4 = byte address in ICDIPTR
STRB R1, [R4]
POP {R4-R5, PC}
.end